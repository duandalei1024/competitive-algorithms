# 最小生成树

## prim算法

**用于稠密图**

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N=510,INF=0x3f3f3f3f;
int n,m;
int g[N][N];
int dist[N];
bool st[N];

int prim(){
    memset(dist,0x3f,sizeof(dist));
    dist[1]=0;
    int res = 0;
    for (int i = 0; i < n;i++){
        int t=-1;
        for (int j = 1; j <= n;j++){
            if(!st[j] && (t==-1 || dist[t] > dist[j])){
                t = j;
            }
        }
    if(dist[t]==INF)  return INF;
    st[t] = true;
    res+=dist[t];
    for (int j = 1;j<=n;j++)  dist[j]=min(dist[j],g[t][j]);
    }
    return res;
}

int main(){
    cin >> n >> m;
    memset(g,0x3f,sizeof(g));
    while(m--){
        int a,b,c;
        cin >> a >> b >> c;
        g[a][b] = g[b][a] = min(g[a][b], c);
    }
    int t=prim();

    if(t==INF)  puts("impossible");
    else cout << t;

    return 0;
}
/*
5 10
1 2 8
2 2 7
2 1 1
3 4 3
4 4 -10
1 3 -9
5 2 -4
3 1 0
1 4 8
4 4 7

输出
-9
*/
```

## kruskal算法

**稀疏图**



```cpp
#include<bits/stdc++.h>

using namespace std;
const int N=100010;


struct Node{
    int a,b,w;
  bool  operator < (const Node &A){
        return w < A.w;
    }
} edge[N];

int n, m;
int f[N];
int findset(int a){
    if(a==f[a]) return a;
    return f[a] = findset(f[a]);
}

int main(){
    cin >> n >> m;
    for (int i = 1; i <= m;i++){
        int x,y,z;
        cin >> x >> y >> z;
        edge[i] = {x, y, z};
    }
    sort(edge+1,edge+1+m);

    for(int i=1;i<=n;i++)  f[i]=i;

    int res=0,cnt=0;
    for (int i = 1;i<=m;i++){
        int a=edge[i].a,b=edge[i].b,w=edge[i].w;
        int fa = findset(a), fb = findset(b);
        if(fa!=fb){
            f[fa] = fb;
            cnt++;
            res += w;
        }
    }
    if(cnt<n-1)  puts("impossible");
    else cout << res;
    return 0;
}
```

# 二分图

## 染色法判断二分图

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N=100010;
int n,m;
int color[N];
vector<int> edge[N];

bool dfs(int u,int c){
    color[u]=c;
    for(auto k : edge[u]){
        if(!color[k]){
            if(!dfs(k,3-c)) return false;
        }else{
            if(color[k]==c) return false;
        }
    }
    return true;
}


int main(){
    cin >> n >> m;
    for (int i = 1; i <= m;i++){
        int x, y;
        cin >> x >> y;
        edge[x].push_back(y);
    }
    bool flag=true;
    for(int i=1;i<=n;i++){
        if(!color[i]){
            if(!dfs(i,1)){
                flag=false;
                break;
            }
        }
    }
    if(flag)  puts("yes");
    else puts("no");

}
/*
4 4
1 3
1 4
2 3
2 4
yes
*/
```

## 匈牙利算法

**计算最大匹配数**

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 510;

int n1, n2, m;
vector<int> edge[N];
int match[N];
bool st[N];

bool find(int x)
{
    for (auto k : edge[x])
    {
        if (!st[k])
        {
            st[k] = true;
            if (match[k] == 0 || find(match[k]))
            {
                match[k] = x;
                return true;
            }
        }
    }
    return false;
}

int main()
{
    cin >> n1 >> n2 >> m;

    for (int i = 1; i <= m; i++)
    {
        int a, b;
        cin >> a >> b;
        edge[a].push_back(b);
    }
    int res = 0;
    for (int i = 1; i <= n1; i++)
    {
        memset(st, false, sizeof(st));
        if (find(i))
            res++;
    }
    cout << res << endl;
    return 0;
}

/*
2 2 4
1 1
1 2
2 1
2 2
输出
2


*/
```

