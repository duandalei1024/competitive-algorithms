# 二分查找的边界处理

#### 题目来源:leetcode704

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。


**示例 1:**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

 

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]`之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。



---

#### 边界的确定:左闭右闭,左闭右开

假设数组的长度为:length

左闭右闭:start=0,end=length-1

左闭右开:start=0,end=length



---

#### 代码的实现

##### 左闭右闭

```cpp
int search(int* nums, int numsSize, int target) {
    int start = 0,end=numsSize-1;
    int mid;
    while(start <= end){   //注意点1
        mid=(start + end)/2;
        if(nums[mid] == target){
            return mid;
        }
        if(nums[mid] > target){
            end = mid - 1;//注意点2
        }
        if(nums[mid] < target){
            start = mid + 1;//注意点3
        }
    }
    return -1;
}
```



注意点1:因为代码总的区间选取的是左闭右闭,所以start和end都在合法区域内,二者能相等

注意点2和注意点3:每次划分的子区间都要和总区间一样,采用左闭右闭.不能写成end=mid;和start=mid;因为,如果start和end相邻时,

nums[mid]选取的数肯定是nums[start],如果此时nums[start]<target,此时start需要右移,但是因为start=mid,start的值和原来的相同

导致跳不出循环,显示运行时间过长.



##### 左闭右开

```cpp
int search(int* nums, int numsSize, int target) {
    int start = 0,end=numsSize;
    int mid;
    while(start < end){//注意点1
        mid=(start + end)/2;
        if(nums[mid] == target){
            return mid;
        }
        if(nums[mid] > target){
            end = mid;//注意点2
        }
        if(nums[mid] < target){
            start = mid+1;//注意点3
        }
    }
    return -1;
}
```



注意点1:因为代码总的区间选取的是左闭右开,所以end不在在合法区域内,二者不能相等

注意点2和注意点3:同理每次划分的子区间都要和总区间一样,采用左闭右开.因为,如果end-start=2时(因为是左闭右开,其实区间中也只有两个元素),此时取到的nums[mid]取到的数是nums[end-1],假设此时的nums[end-1]>target,end需要左移,如果end=mid-1,此时end就等于start不满足总的循环条件,就会跳出循环,返回-1.



---

#### 总结

**每次分割出的子区间要与原先确定的数组区间形式保持一致**











