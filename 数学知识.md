# 质数

## 分解质因数

```cpp
#include <bits/stdc++.h>

using namespace std;
int s;

void divide(int n)
{

    for (int i = 2; i <= n; i++)
    {
        if (n % i == 0)
        {
            int s = 0;
            while (n % i == 0)
            {
                n /= i;
                s++;
            }
        }
        printf("%d %d\n", i, s);
    }
}

// 优化=>n中最多只包含1个大于sprt(n)的质因子
void divide(int n)
{

    for (int i = 2; i <= n / i; i++)   //i*i<=n 写成i<=n/i
    {
        if (n % i == 0)
        {
            int s = 0;
            while (n % i == 0)
            {
                n /= i;
                s++;
            }
            printf("%d %d\n", i, s);
        }
    }
    if(n>1)  printf("%d %d\n", n, 1);
}
```

## 质数筛

 ###  埃式筛法

**在到达i之前,把2~i-1之间的数筛了一遍**

```cpp
#include<bits/stdc++.h>

using namespace std;
const int N = 100010;
int n,cnt;
int prime[N];
bool st[N];

void get_prime(int n){
   for(int i=2;i<=n;i++){
    if(!st[i])  {
        prime[cnt++] = i;      
    }
    for (int j = i + i; j <= n;j+=i) st[j]=true;
   }
}

int main(){
    int n;
    cin >> n;
    get_prime(n);
    cout << cnt;
}
```

**算数基本定理优化**

```cpp
void get_prime(int n){
   for(int i=2;i<=n;i++){
    if(!st[i])  {
        prime[cnt++] = i;
  for (int j = i + i; j <= n;j+=i) st[j]=true;       
    }
   }
}
```

### 线性筛法

**每个和数只会被筛一遍**

**筛除最小质因子优化**

```cpp
//筛除最小质因子
void get_prime(int n)
{
    for (int i = 2; i <= n; i++)
    {
        if(!st[i]) prime[cnt++]=i;
        for (int j = 0; prime[j] <= n / i;j++){
            st[prime[j]*i] =true;
            if(i%prime[j]==0) break;
        }
    }
}
```



**此时i为一个数,a是i的最小质因子,prime[j]是小于a的质数,根据算数基本定理,两个相乘,就组成了一个新的数,这个数的最小质因子就是prime[j]**

**相当于每次删除了所有小于a的质数与i重构的数**

